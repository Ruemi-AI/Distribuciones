<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probabilidad y Estadística: Distribuciones</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #eef2f7;
            color: #333;
            line-height: 1.6;
        }

        header {
            background-color: #28a745; /* Verde vibrante */
            color: white;
            padding: 1.5rem 0;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            margin: 0;
            font-size: 2.5em;
        }

        header p {
            margin: 5px 0 0;
            font-size: 1.1em;
            opacity: 0.9;
        }

        nav {
            background-color: #343a40; /* Gris oscuro */
            overflow: hidden;
            text-align: center;
            padding: 0.8rem 0;
            border-bottom: 3px solid #218838;
        }

        nav button {
            background-color: #495057; /* Gris un poco más claro */
            color: white;
            padding: 12px 22px;
            margin: 0 8px;
            border: none;
            cursor: pointer;
            font-size: 1.1em;
            border-radius: 6px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        nav button:hover {
            background-color: #6c757d;
            transform: translateY(-2px);
        }

        main {
            padding: 30px;
            max-width: 1300px;
            margin: 30px auto;
            background-color: white;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
        }

        .hidden-section {
            display: none;
        }

        .active-section {
            display: block;
        }

        h2 {
            color: #28a745;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 0;
            font-size: 2em;
        }

        #game-container, #distribution-details-container {
            margin-top: 25px;
            padding: 25px;
            border: 1px solid #d4edda; /* Borde verde claro */
            border-radius: 10px;
            background-color: #e2ffe8; /* Fondo verde muy claro */
            box-shadow: inset 0 0 10px rgba(0, 123, 255, 0.05);
        }

        #draw-balls-button {
            background-color: #007bff; /* Azul primario */
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #draw-balls-button:hover {
            background-color: #0056b3;
        }

        #result {
            margin-top: 20px;
            font-size: 1.3em;
            font-weight: bold;
            color: #0056b3;
        }

        /* Contenedores para hacer las gráficas más pequeñas */
        .chart-container {
            position: relative;
            width: 70%; /* Ajusta el ancho según tu preferencia */
            max-width: 600px; /* Ancho máximo para no crecer demasiado */
            margin: 20px auto; /* Centrar el contenedor */
            min-height: 300px; /* Altura mínima para que no se colapsen */
        }

        canvas {
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            padding: 10px;
            /* Estos estilos se manejan mejor a través del contenedor ahora */
            width: 100% !important; /* Asegurar que el canvas ocupe el 100% de su contenedor */
            height: auto !important; /* Mantener la proporción */
        }

        #distribution-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        #distribution-buttons button {
            padding: 10px 18px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #distribution-buttons button:hover {
            background-color: #5a6268;
            transform: translateY(-1px);
        }

        .distribution-content {
            margin-top: 25px;
            padding: 25px;
            border: 1px solid #cce5ff; /* Borde azul claro */
            border-radius: 10px;
            background-color: #e7f5ff; /* Fondo azul muy claro */
            box-shadow: inset 0 0 10px rgba(0, 123, 255, 0.05);
        }

        .distribution-content h3 {
            color: #007bff;
            margin-top: 0;
            font-size: 1.8em;
            border-bottom: 1px solid #b3d9ff;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }

        .distribution-content p {
            margin-bottom: 10px;
        }

        .input-fields label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        .input-fields input[type="number"] {
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            width: calc(100% - 22px);
            max-width: 250px;
            font-size: 1em;
        }

        .distribution-content button {
            padding: 10px 18px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .distribution-content button:hover {
            background-color: #218838;
        }

        footer {
            text-align: center;
            padding: 1.2rem 0;
            background-color: #343a40;
            color: white;
            margin-top: 40px;
            font-size: 0.9em;
            box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <header>
        <h1>Distribuciones y Densidades de Probabilidad</h1>
        <p>Probabilidad y Estadística</p>
    </header>

    <nav>
        <button onclick="showSection('game')">Juego de Pelotas</button>
        <button onclick="showSection('distributions')">Generación de Distribuciones</button>
    </nav>

    <main>
        <section id="home-section" class="active-section">
            <h2>Bienvenido</h2>
            <p>Este proyecto interactivo te ayudará a comprender las **distribuciones y densidades de probabilidad**.</p>
            <p>Explora el **Juego de Pelotas** para visualizar una distribución discreta en acción, o sumérgete en la **Generación de Distribuciones** para interactuar con diversas distribuciones estadísticas.</p>
        </section>

        <section id="game-section" class="hidden-section">
            <h2>Juego de Pelotas: Suma de Números</h2>
            <p>Imagina una urna con 4 pelotas numeradas del 1 al 4. Si sacas **dos pelotas al azar sin reemplazo**, y $Z$ es la **suma de los números** de las pelotas que sacaste, ¿cuál será la distribución de probabilidad de $Z$?</p>
            <p>¡Haz clic en "Sacar 2 Pelotas" para simular extracciones y observa cómo se forma la distribución de $Z$!</p>
            <div id="game-container">
                <button id="draw-balls-button">Sacar 2 Pelotas</button>
                <div id="result"></div>
                <div class="chart-container">
                    <canvas id="game-chart"></canvas>
                </div>
            </div>
        </section>

        <section id="distributions-section" class="hidden-section">
            <h2>Generación de Distribuciones</h2>
            <p>Elige una distribución para explorar su funcionamiento. Podrás ajustar sus parámetros, generar un gran número de muestras aleatorias, y ver la **media**, **varianza** y otros **momentos** calculados, junto con un **gráfico** de la distribución empírica.</p>
            <nav id="distribution-buttons">
                <button onclick="showDistribution('bernoulli')">Bernoulli</button>
                <button onclick="showDistribution('binomial')">Binomial</button>
                <button onclick="showDistribution('negative-binomial')">Binomial Negativa</button>
                <button onclick="showDistribution('geometric')">Geométrica</button>
                <button onclick="showDistribution('hypergeometric')">Hipergeométrica</button>
                <button onclick="showDistribution('poisson')">Poisson</button>
                <button onclick="showDistribution('uniform')">Uniforme</button>
                <button onclick="showDistribution('gaussian')">Gaussiana (Normal)</button>
                <button onclick="showDistribution('exponential')">Exponencial</button>
                <button onclick="showDistribution('gamma')">Gamma</button>
            </nav>

            <div id="distribution-details-container">
                <p>Haz clic en uno de los botones de distribución para comenzar.</p>
            </div>
        </section>
    </main>

    <footer>
        <p>Proyecto de Probabilidad y Estadística &copy; 2025</p>
    </footer>

    <script>
        // Función para mostrar/ocultar secciones
        function showSection(sectionId) {
            document.querySelectorAll('section').forEach(section => {
                section.classList.remove('active-section');
                section.classList.add('hidden-section');
            });
            document.getElementById(sectionId + '-section').classList.remove('hidden-section');
            document.getElementById(sectionId + '-section').classList.add('active-section');
            
            // Limpiar el contenido de la distribución cuando se cambia de sección
            if (sectionId !== 'distributions') {
                document.getElementById('distribution-details-container').innerHTML = '<p>Haz clic en uno de los botones de distribución para comenzar.</p>';
                if (currentChart) {
                    currentChart.destroy();
                    currentChart = null;
                }
            }
             // Asegurarse de que el gráfico del juego se actualice al volver
            if (sectionId === 'game' && gameChart) {
                gameChart.update();
            }
        }

        // --- Lógica del Juego de Pelotas ---
        const drawBallsButton = document.getElementById('draw-balls-button');
        const resultDiv = document.getElementById('result');
        const gameChartCanvas = document.getElementById('game-chart');
        let gameChart; // Para almacenar la instancia de Chart.js del juego

        const possibleSums = {}; // Para almacenar la frecuencia de las sumas

        // Inicializar el gráfico del juego al cargar
        document.addEventListener('DOMContentLoaded', () => {
             updateGameChart(); // Crea un gráfico vacío o inicial
        });

        drawBallsButton.addEventListener('click', () => {
            const urn = [1, 2, 3, 4];
            let balls = [];

            // Selección aleatoria simple sin reemplazo
            const index1 = Math.floor(Math.random() * urn.length);
            balls.push(urn[index1]);
            urn.splice(index1, 1); // Remover la pelota seleccionada

            const index2 = Math.floor(Math.random() * urn.length);
            balls.push(urn[index2]);

            const sum = balls[0] + balls[1];
            resultDiv.innerHTML = `Pelotas sacadas: <b>${balls[0]}</b> y <b>${balls[1]}</b>. Suma ($Z$): <b>${sum}</b>`;

            // Actualizar la frecuencia
            possibleSums[sum] = (possibleSums[sum] || 0) + 1;
            updateGameChart();
        });

        function updateGameChart() {
            // Ordenar las etiquetas numéricamente
            const labels = Object.keys(possibleSums).map(Number).sort((a, b) => a - b);
            const data = labels.map(label => possibleSums[label]);

            if (gameChart) {
                gameChart.destroy(); // Destruir el gráfico anterior para evitar conflictos
            }

            gameChart = new Chart(gameChartCanvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Frecuencia de Sumas (Z)',
                        data: data,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Permitir que el tamaño se ajuste al contenedor
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frecuencia'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Suma (Z)'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Distribución Empírica de Z (Suma de Pelotas)'
                        }
                    }
                }
            });
        }

        // --- Lógica de Generación de Distribuciones ---
        const distributionDetailsContainer = document.getElementById('distribution-details-container');
        let currentChart; // Para almacenar la instancia de Chart.js para las distribuciones

        function showDistribution(distType) {
            let content = '';
            let description = '';
            let inputFields = '';
            let generateFunction = '';

            // Destruir el gráfico anterior si existe
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }

            switch (distType) {
                case 'bernoulli':
                    description = `
                        <h3>Distribución de Bernoulli</h3>
                        <p>Describe un experimento con solo dos resultados posibles: **éxito** (con probabilidad $p$) o **fracaso** (con probabilidad $1-p$). Es la base de muchas otras distribuciones.</p>
                        <p><b>Parámetros:</b> $p$ (probabilidad de éxito)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = p$</p>
                        <p><b>Varianza:</b> $Var(X) = p(1-p)$</p>
                    `;
                    inputFields = `
                        <label for="bernoulli-p">Probabilidad de éxito ($p$):</label>
                        <input type="number" id="bernoulli-p" min="0" max="1" step="0.01" value="0.5"><br>
                        <label for="num-samples-bernoulli">Número de muestras:</label>
                        <input type="number" id="num-samples-bernoulli" min="1" value="1000">
                    `;
                    generateFunction = `generateBernoulli`;
                    break;
                case 'binomial':
                    description = `
                        <h3>Distribución Binomial</h3>
                        <p>Describe el número de **éxitos** en una secuencia de $n$ **ensayos de Bernoulli independientes**, cada uno con una probabilidad $p$ de éxito. Por ejemplo, el número de caras al lanzar una moneda 10 veces.</p>
                        <p><b>Parámetros:</b> $n$ (número de ensayos), $p$ (probabilidad de éxito)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = np$</p>
                        <p><b>Varianza:</b> $Var(X) = np(1-p)$</p>
                    `;
                    inputFields = `
                        <label for="binomial-n">Número de ensayos ($n$):</label>
                        <input type="number" id="binomial-n" min="1" value="10"><br>
                        <label for="binomial-p">Probabilidad de éxito ($p$):</label>
                        <input type="number" id="binomial-p" min="0" max="1" step="0.01" value="0.5"><br>
                        <label for="num-samples-binomial">Número de muestras:</label>
                        <input type="number" id="num-samples-binomial" min="1" value="1000">
                    `;
                    generateFunction = `generateBinomial`;
                    break;
                case 'negative-binomial':
                    description = `
                        <h3>Distribución Binomial Negativa</h3>
                        <p>Describe el número de **fracasos** que ocurren antes de obtener un número fijo de **éxitos** ($r$) en una secuencia de ensayos de Bernoulli. (Algunas definiciones la consideran el número total de ensayos).</p>
                        <p><b>Parámetros:</b> $r$ (número de éxitos deseados), $p$ (probabilidad de éxito)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = r(1-p)/p$ (número de fracasos)</p>
                        <p><b>Varianza:</b> $Var(X) = r(1-p)/p^2$</p>
                    `;
                    inputFields = `
                        <label for="neg-binomial-r">Número de éxitos deseados ($r$):</label>
                        <input type="number" id="neg-binomial-r" min="1" value="5"><br>
                        <label for="neg-binomial-p">Probabilidad de éxito ($p$):</label>
                        <input type="number" id="neg-binomial-p" min="0" max="1" step="0.01" value="0.5"><br>
                        <label for="num-samples-neg-binomial">Número de muestras:</label>
                        <input type="number" id="num-samples-neg-binomial" min="1" value="1000">
                    `;
                    generateFunction = `generateNegativeBinomial`;
                    break;
                case 'geometric':
                    description = `
                        <h3>Distribución Geométrica</h3>
                        <p>Describe el número de **ensayos de Bernoulli** necesarios (incluido el éxito) para obtener el **primer éxito**. Es un caso especial de la Binomial Negativa con $r=1$.</p>
                        <p><b>Parámetros:</b> $p$ (probabilidad de éxito)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = 1/p$</p>
                        <p><b>Varianza:</b> $Var(X) = (1-p)/p^2$</p>
                    `;
                    inputFields = `
                        <label for="geometric-p">Probabilidad de éxito ($p$):</label>
                        <input type="number" id="geometric-p" min="0" max="1" step="0.01" value="0.5"><br>
                        <label for="num-samples-geometric">Número de muestras:</label>
                        <input type="number" id="num-samples-geometric" min="1" value="1000">
                    `;
                    generateFunction = `generateGeometric`;
                    break;
                case 'hypergeometric':
                    description = `
                        <h3>Distribución Hipergeométrica</h3>
                        <p>Describe la probabilidad de obtener un número específico de éxitos en una **muestra sin reemplazo** de una población finita. A diferencia de la Binomial, la probabilidad de éxito cambia con cada extracción.</p>
                        <p><b>Parámetros:</b> $N$ (tamaño de la población), $K$ (número de éxitos en la población), $n$ (tamaño de la muestra)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = nK/N$</p>
                        <p><b>Varianza:</b> $Var(X) = n \\cdot (K/N) \\cdot ((N-K)/N) \\cdot ((N-n)/(N-1))$</p>
                    `;
                    inputFields = `
                        <label for="hyper-N">Tamaño de la población ($N$):</label>
                        <input type="number" id="hyper-N" min="1" value="20"><br>
                        <label for="hyper-K">Número de éxitos en la población ($K$):</label>
                        <input type="number" id="hyper-K" min="0" value="10"><br>
                        <label for="hyper-n">Tamaño de la muestra ($n$):</label>
                        <input type="number" id="hyper-n" min="1" value="5"><br>
                        <label for="num-samples-hyper">Número de muestras:</label>
                        <input type="number" id="num-samples-hyper" min="1" value="1000">
                    `;
                    generateFunction = `generateHypergeometric`;
                    break;
                case 'poisson':
                    description = `
                        <h3>Distribución de Poisson</h3>
                        <p>Describe el número de eventos que ocurren en un intervalo fijo de tiempo o espacio, si estos eventos ocurren con una **tasa promedio conocida** ($\\lambda$) y de forma independiente.</p>
                        <p><b>Parámetros:</b> $\\lambda$ (tasa promedio de ocurrencia)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = \\lambda$</p>
                        <p><b>Varianza:</b> $Var(X) = \\lambda$</p>
                    `;
                    inputFields = `
                        <label for="poisson-lambda">Tasa promedio (λ):</label>
                        <input type="number" id="poisson-lambda" min="0.1" step="0.1" value="3"><br>
                        <label for="num-samples-poisson">Número de muestras:</label>
                        <input type="number" id="num-samples-poisson" min="1" value="1000">
                    `;
                    generateFunction = `generatePoisson`;
                    break;
                case 'uniform':
                    description = `
                        <h3>Distribución Uniforme</h3>
                        <p>Describe una variable donde **todos los valores** dentro de un rango dado ($a, b$) tienen la **misma probabilidad de ocurrir**. Es la base para generar otras distribuciones.</p>
                        <p><b>Parámetros:</b> $a$ (límite inferior), $b$ (límite superior)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = (a+b)/2$</p>
                        <p><b>Varianza:</b> $Var(X) = (b-a)^2/12$</p>
                    `;
                    inputFields = `
                        <label for="uniform-a">Límite inferior ($a$):</label>
                        <input type="number" id="uniform-a" value="0"><br>
                        <label for="uniform-b">Límite superior ($b$):</label>
                        <input type="number" id="uniform-b" value="10"><br>
                        <label for="num-samples-uniform">Número de muestras:</label>
                        <input type="number" id="num-samples-uniform" min="1" value="1000">
                    `;
                    generateFunction = `generateUniform`;
                    break;
                case 'gaussian':
                    description = `
                        <h3>Distribución Gaussiana (Normal)</h3>
                        <p>Es una de las distribuciones más importantes en estadística, caracterizada por su **forma de "campana"**. Muchos fenómenos naturales y mediciones siguen esta distribución.</p>
                        <p><b>Parámetros:</b> $\\mu$ (media), $\\sigma$ (desviación estándar)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = \\mu$</p>
                        <p><b>Varianza:</b> $Var(X) = \\sigma^2$</p>
                    `;
                    inputFields = `
                        <label for="gaussian-mu">Media ($\mu$):</label>
                        <input type="number" id="gaussian-mu" value="0"><br>
                        <label for="gaussian-sigma">Desviación estándar ($\sigma$):</label>
                        <input type="number" id="gaussian-sigma" min="0.1" step="0.1" value="1"><br>
                        <label for="num-samples-gaussian">Número de muestras:</label>
                        <input type="number" id="num-samples-gaussian" min="1" value="1000">
                    `;
                    generateFunction = `generateGaussian`;
                    break;
                case 'exponential':
                    description = `
                        <h3>Distribución Exponencial</h3>
                        <p>Describe el **tiempo de espera** hasta que ocurre el primer evento en un proceso de Poisson continuo, o el tiempo entre eventos sucesivos en dicho proceso.</p>
                        <p><b>Parámetros:</b> $\\lambda$ (tasa de ocurrencia, $1/\\lambda$ es el tiempo promedio de espera)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = 1/\\lambda$</p>
                        <p><b>Varianza:</b> $Var(X) = 1/\\lambda^2$</p>
                    `;
                    inputFields = `
                        <label for="exponential-lambda">Tasa (λ):</label>
                        <input type="number" id="exponential-lambda" min="0.1" step="0.1" value="0.5"><br>
                        <label for="num-samples-exponential">Número de muestras:</label>
                        <input type="number" id="num-samples-exponential" min="1" value="1000">
                    `;
                    generateFunction = `generateExponential`;
                    break;
                case 'gamma':
                    description = `
                        <h3>Distribución Gamma</h3>
                        <p>Una distribución de probabilidad continua que describe el tiempo de espera hasta que ocurre un número específico de eventos en un proceso de Poisson. Generaliza la distribución Exponencial y la distribución Chi-cuadrado.</p>
                        <p><b>Parámetros:</b> $\\alpha$ (parámetro de forma, *shape*), $\\beta$ (parámetro de razón, *rate*)</p>
                        <p><b>Media (Esperanza):</b> $E[X] = \\alpha / \\beta$</p>
                        <p><b>Varianza:</b> $Var(X) = \\alpha / \\beta^2$</p>
                        <p>Nota: La generación para $\\alpha$ no entero es compleja. Aquí se usa una aproximación para $\\alpha$ entero.</p>
                    `;
                    inputFields = `
                        <label for="gamma-alpha">Parámetro de forma (α):</label>
                        <input type="number" id="gamma-alpha" min="0.1" step="0.1" value="2"><br>
                        <label for="gamma-beta">Parámetro de razón (β):</label>
                        <input type="number" id="gamma-beta" min="0.1" step="0.1" value="1"><br>
                        <label for="num-samples-gamma">Número de muestras:</label>
                        <input type="number" id="num-samples-gamma" min="1" value="1000">
                    `;
                    generateFunction = `generateGamma`;
                    break;
                default:
                    content = '<p>Selecciona una distribución para ver sus detalles.</p>';
                    break;
            }

            if (distType !== '') {
                content = `
                    <div class="distribution-content">
                        ${description}
                        <div class="input-fields">
                            ${inputFields}
                        </div>
                        <button onclick="${generateFunction}()">Generar y Graficar</button>
                        <div id="results-${distType}" style="margin-top: 15px;"></div>
                        <div class="chart-container">
                            <canvas id="chart-${distType}"></canvas>
                        </div>
                    </div>
                `;
            }

            distributionDetailsContainer.innerHTML = content;
            if (MathJax) { // Renderizar LaTeX si MathJax está disponible
                MathJax.typeset();
            }
        }

        // --- Funciones auxiliares para la generación de números aleatorios ---
        // Generador de números uniformes (0, 1)
        function random() {
            return Math.random();
        }

        // Generación de Bernoulli (0 o 1)
        function generateBernoulli() {
            const p = parseFloat(document.getElementById('bernoulli-p').value);
            const numSamples = parseInt(document.getElementById('num-samples-bernoulli').value);
            if (isNaN(p) || p < 0 || p > 1) { alert("Probabilidad (p) debe ser entre 0 y 1."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = Array.from({ length: numSamples }, () => (random() < p ? 1 : 0));
            analyzeAndPlot(samples, 'bernoulli', p, p * (1 - p));
        }

        // Generación Binomial
        function generateBinomial() {
            const n = parseInt(document.getElementById('binomial-n').value);
            const p = parseFloat(document.getElementById('binomial-p').value);
            const numSamples = parseInt(document.getElementById('num-samples-binomial').value);
            if (isNaN(n) || n < 1) { alert("Número de ensayos (n) debe ser al menos 1."); return; }
            if (isNaN(p) || p < 0 || p > 1) { alert("Probabilidad (p) debe ser entre 0 y 1."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = [];
            for (let i = 0; i < numSamples; i++) {
                let successes = 0;
                for (let j = 0; j < n; j++) {
                    if (random() < p) {
                        successes++;
                    }
                }
                samples.push(successes);
            }
            analyzeAndPlot(samples, 'binomial', n * p, n * p * (1 - p));
        }

        // Generación Binomial Negativa (número de fracasos antes de r éxitos)
        function generateNegativeBinomial() {
            const r = parseInt(document.getElementById('neg-binomial-r').value);
            const p = parseFloat(document.getElementById('neg-binomial-p').value);
            const numSamples = parseInt(document.getElementById('num-samples-neg-binomial').value);
            if (isNaN(r) || r < 1) { alert("Número de éxitos deseados (r) debe ser al menos 1."); return; }
            if (isNaN(p) || p < 0 || p > 1) { alert("Probabilidad (p) debe ser entre 0 y 1."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = [];
            for (let i = 0; i < numSamples; i++) {
                let successes = 0;
                let failures = 0; // Contar los fracasos
                while (successes < r) {
                    if (random() < p) {
                        successes++;
                    } else {
                        failures++;
                    }
                }
                samples.push(failures);
            }
            analyzeAndPlot(samples, 'negative-binomial', r * (1 - p) / p, r * (1 - p) / (p * p));
        }

        // Generación Gamma (simplificado para alpha entero, sumando exponenciales)
        function generateGamma() {
            const alpha = parseFloat(document.getElementById('gamma-alpha').value);
            const beta = parseFloat(document.getElementById('gamma-beta').value);
            const numSamples = parseInt(document.getElementById('num-samples-gamma').value);
            if (isNaN(alpha) || alpha <= 0) { alert("Parámetro de forma (α) debe ser positivo."); return; }
            if (isNaN(beta) || beta <= 0) { alert("Parámetro de razón (β) debe ser positivo."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = [];
            if (Number.isInteger(alpha)) {
                // Para alpha entero, Gamma(alpha, beta) es la suma de alpha exponenciales(beta)
                for (let i = 0; i < numSamples; i++) {
                    let sumExponentials = 0;
                    for (let j = 0; j < alpha; j++) {
                        sumExponentials += -Math.log(random()) / beta; // Generar Exponential(beta)
                    }
                    samples.push(sumExponentials);
                }
            } else {
                // Para alpha no entero, se requiere un algoritmo más complejo (ej. Marsaglia and Tsang)
                // Esto es una simplificación o un placeholder si no se implementa un algoritmo completo
                alert("La generación de la distribución Gamma para un parámetro de forma (α) no entero es compleja y no está completamente implementada en esta demostración. Se generarán valores aproximados.");
                 for (let i = 0; i < numSamples; i++) {
                    // Placeholder: genera números aleatorios uniformes si alpha no es entero para evitar errores
                    // ¡Esto NO es una distribución Gamma real para alpha no entero!
                    samples.push(Math.pow(random(), 1/alpha) * (alpha / beta));
                }
            }
            analyzeAndPlot(samples, 'gamma', alpha / beta, alpha / (beta * beta), true); // true para distribución continua
        }

        // Generación de Poisson (usando el método de transformación inversa)
        function generatePoisson() {
            const lambda = parseFloat(document.getElementById('poisson-lambda').value);
            const numSamples = parseInt(document.getElementById('num-samples-poisson').value);
            if (isNaN(lambda) || lambda <= 0) { alert("Tasa promedio (λ) debe ser positiva."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = [];
            for (let i = 0; i < numSamples; i++) {
                let k = 0;
                let p = 1;
                const L = Math.exp(-lambda);
                do {
                    k++;
                    p *= random();
                } while (p > L);
                samples.push(k - 1);
            }
            analyzeAndPlot(samples, 'poisson', lambda, lambda);
        }

        // Generación Geométrica (número de ensayos hasta el primer éxito)
        function generateGeometric() {
            const p = parseFloat(document.getElementById('geometric-p').value);
            const numSamples = parseInt(document.getElementById('num-samples-geometric').value);
            if (isNaN(p) || p <= 0 || p > 1) { alert("Probabilidad (p) debe ser entre 0 y 1 (excluyendo 0)."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = [];
            for (let i = 0; i < numSamples; i++) {
                let trials = 1;
                while (random() >= p) {
                    trials++;
                }
                samples.push(trials);
            }
            analyzeAndPlot(samples, 'geometric', 1 / p, (1 - p) / (p * p));
        }

        // Generación Hipergeométrica (simulando extracciones sin reemplazo)
        function generateHypergeometric() {
            const N = parseInt(document.getElementById('hyper-N').value);
            const K = parseInt(document.getElementById('hyper-K').value);
            const n = parseInt(document.getElementById('hyper-n').value);
            const numSamples = parseInt(document.getElementById('num-samples-hyper').value);

            if (isNaN(N) || N < 1) { alert("Tamaño de la población (N) debe ser al menos 1."); return; }
            if (isNaN(K) || K < 0 || K > N) { alert("Número de éxitos en la población (K) debe ser entre 0 y N."); return; }
            if (isNaN(n) || n < 1 || n > N) { alert("Tamaño de la muestra (n) debe ser entre 1 y N."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = [];
            for (let i = 0; i < numSamples; i++) {
                // Representación de la población: 1 para éxito, 0 para fracaso
                let population = Array(K).fill(1).concat(Array(N - K).fill(0));
                let successesInSample = 0;
                let tempPopulation = [...population]; // Crear una copia para cada muestra

                for (let j = 0; j < n; j++) {
                    const index = Math.floor(random() * tempPopulation.length);
                    if (tempPopulation[index] === 1) {
                        successesInSample++;
                    }
                    tempPopulation.splice(index, 1); // Remover sin reemplazo
                }
                samples.push(successesInSample);
            }
            const expectedMean = (n * K) / N;
            const expectedVariance = n * (K / N) * ((N - K) / N) * ((N - n) / (N - 1));
            analyzeAndPlot(samples, 'hypergeometric', expectedMean, expectedVariance);
        }

        // Generación Uniforme
        function generateUniform() {
            const a = parseFloat(document.getElementById('uniform-a').value);
            const b = parseFloat(document.getElementById('uniform-b').value);
            const numSamples = parseInt(document.getElementById('num-samples-uniform').value);
            if (isNaN(a) || isNaN(b)) { alert("Límites a y b deben ser números."); return; }
            if (a >= b) { alert("El límite inferior (a) debe ser menor que el límite superior (b)."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = Array.from({ length: numSamples }, () => a + (b - a) * random());
            analyzeAndPlot(samples, 'uniform', (a + b) / 2, (b - a) * (b - a) / 12, true);
        }

        // Generación Gaussiana (Normal) (usando la transformada de Box-Muller)
        function generateGaussian() {
            const mu = parseFloat(document.getElementById('gaussian-mu').value);
            const sigma = parseFloat(document.getElementById('gaussian-sigma').value);
            const numSamples = parseInt(document.getElementById('num-samples-gaussian').value);
            if (isNaN(mu) || isNaN(sigma)) { alert("Media (μ) y desviación estándar (σ) deben ser números."); return; }
            if (sigma <= 0) { alert("La desviación estándar (σ) debe ser positiva."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = [];
            let extraRandom = null;

            for (let i = 0; i < numSamples; i++) {
                let u1, u2, z0;
                if (extraRandom !== null) {
                    z0 = extraRandom;
                    extraRandom = null;
                } else {
                    do {
                        u1 = random();
                        u2 = random();
                    } while (u1 === 0); // Evitar log(0)
                    const r = Math.sqrt(-2.0 * Math.log(u1));
                    const theta = 2.0 * Math.PI * u2;
                    z0 = r * Math.cos(theta);
                    extraRandom = r * Math.sin(theta); // Almacenar uno para la siguiente llamada
                }
                samples.push(z0 * sigma + mu);
            }
            analyzeAndPlot(samples, 'gaussian', mu, sigma * sigma, true);
        }

        // Generación Exponencial
        function generateExponential() {
            const lambda = parseFloat(document.getElementById('exponential-lambda').value);
            const numSamples = parseInt(document.getElementById('num-samples-exponential').value);
            if (isNaN(lambda) || lambda <= 0) { alert("Tasa (λ) debe ser positiva."); return; }
            if (isNaN(numSamples) || numSamples < 1) { alert("Número de muestras debe ser al menos 1."); return; }

            const samples = Array.from({ length: numSamples }, () => -Math.log(1 - random()) / lambda);
            analyzeAndPlot(samples, 'exponential', 1 / lambda, 1 / (lambda * lambda), true);
        }

        // --- Función de Análisis y Trazado de Gráficos ---
        function analyzeAndPlot(samples, distType, expectedMean, expectedVariance, isContinuous = false) {
            const resultsDiv = document.getElementById(`results-${distType}`);
            const chartCanvas = document.getElementById(`chart-${distType}`);

            // Cálculo de la Media (Esperanza Matemática)
            const sum = samples.reduce((acc, val) => acc + val, 0);
            const mean = sum / samples.length;

            // Cálculo de la Varianza (varianza poblacional para los datos generados)
            const squaredDifferencesSum = samples.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
            const variance = squaredDifferencesSum / samples.length;

            // Cálculo de la Desviación Estándar
            const stdDev = Math.sqrt(variance);

            // Cálculo del Sesgo (3er Momento Central normalizado)
            const thirdMoment = samples.reduce((acc, val) => acc + Math.pow(val - mean, 3), 0) / samples.length;
            const skewness = stdDev === 0 ? 0 : thirdMoment / Math.pow(stdDev, 3); // Evitar división por cero

            // Cálculo de la Curtosis (4to Momento Central normalizado - 3 para exceso de curtosis)
            const fourthMoment = samples.reduce((acc, val) => acc + Math.pow(val - mean, 4), 0) / samples.length;
            const kurtosis = stdDev === 0 ? 0 : (fourthMoment / Math.pow(stdDev, 4)) - 3; // Exceso de Curtosis

            resultsDiv.innerHTML = `
                <p><b>Muestras generadas:</b> ${samples.length}</p>
                <p><b>Media Muestral (Esperanza):</b> ${mean.toFixed(4)} (Esperada: ${expectedMean !== undefined ? expectedMean.toFixed(4) : 'N/A'})</p>
                <p><b>Varianza Muestral:</b> ${variance.toFixed(4)} (Esperada: ${expectedVariance !== undefined ? expectedVariance.toFixed(4) : 'N/A'})</p>
                <p><b>Desviación Estándar:</b> ${stdDev.toFixed(4)}</p>
                <p><b>Asimetría (Skewness):</b> ${skewness.toFixed(4)}</p>
                <p><b>Curtosis (Exceso de Kurtosis):</b> ${kurtosis.toFixed(4)}</p>
            `;

            // Generar Histograma para la visualización
            if (currentChart) {
                currentChart.destroy();
            }

            let labels, data, type, chartTitle;
            if (isContinuous) {
                // Para distribuciones continuas, crear "bins" para el histograma
                const minVal = Math.min(...samples);
                const maxVal = Math.max(...samples);
                const numBins = 30; // Puedes ajustar este número de bins
                const binSize = (maxVal - minVal) / numBins;
                const bins = Array(numBins).fill(0);
                labels = [];

                for(let i = 0; i < numBins; i++) {
                    labels.push(`${(minVal + i * binSize).toFixed(2)} - ${(minVal + (i + 1) * binSize).toFixed(2)}`);
                }

                samples.forEach(sample => {
                    let binIndex = Math.floor((sample - minVal) / binSize);
                    if (binIndex >= numBins) binIndex = numBins - 1;
                    if (binIndex < 0) binIndex = 0;
                    bins[binIndex]++;
                });
                data = bins;
                type = 'bar'; // Un gráfico de barras simula un histograma
                chartTitle = `Histograma de la Distribución ${distType.charAt(0).toUpperCase() + distType.slice(1)}`;
            } else {
                // Para distribuciones discretas, contar ocurrencias
                const counts = {};
                samples.forEach(s => {
                    counts[s] = (counts[s] || 0) + 1;
                });
                labels = Object.keys(counts).map(Number).sort((a, b) => a - b);
                data = labels.map(label => counts[label]);
                type = 'bar';
                chartTitle = `Distribución de Frecuencia de ${distType.charAt(0).toUpperCase() + distType.slice(1)}`;
            }

            currentChart = new Chart(chartCanvas, {
                type: type,
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Frecuencia de Muestras`,
                        data: data,
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Importante para que el tamaño se ajuste al contenedor
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frecuencia'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Valor'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    if (isContinuous) {
                                        return `Rango: ${context[0].label}`;
                                    }
                                    return `Valor: ${context[0].label}`;
                                },
                                label: function(context) {
                                    return `Frecuencia: ${context.formattedValue}`;
                                }
                            }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>